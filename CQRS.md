https://www.cnblogs.com/yangecnu/p/Introduction-CQRS.html
CRUD - Data-Driven
![image](https://images0.cnblogs.com/blog/94031/201408/261851413457170.png)

Problems:
使用同一個對象實體來進行數據庫讀寫可能會太粗糙，大多數情況下，比如編輯的時候可能只需要更新個別字段，但是卻需要將整個對象都穿進去，有些字段其實是不需要更新的。在查詢的時候在表現層可能只需要個別字段，但是需要查詢和返回整個實體對象。

使用同一實體對象對同一數據進行讀寫操作的時候，可能會遇到資源競爭的情況，經常要處理的鎖的問題，在寫入數據的時候，需要加鎖。讀取數據的時候需要判斷是否允許臟讀。這樣使得系統的邏輯性和複雜性增加，並且會對系統吞吐量的增長會產生影響。

同步的，直接與數據庫進行交互在大數據量同時訪問的情況下可能會影響性能和響應性，並且可能會產生性能瓶頸。
由於同一實體對象都會在讀寫操作中用到，所以對於安全和權限的管理會變得比較複雜。

這裡面很重要的一個問題是，系統中的讀寫頻率比，是偏向讀，還是偏向寫，就如同一般的數據結構在查找和修改上時間複雜度不一樣，在設計系統的結構時也需要考慮這樣的問題。

Solution:
解決方法就是我們經常用到的對數據庫進行讀寫分離。讓主數據庫處理事務性的增，刪，改操作（插入，更新，刪除）操作，讓從數據庫處理查詢操作（選擇操作），數據庫複製被用來將事務性操作導致的變更同步到集群中的從數據庫。這只是從DB角度處理了讀寫分離，但是從業務或者系統上面讀和寫仍然是存放在一起的。他們都是用的同一個實體對象。

CQRS
命令（指令）：不返回任何結果（無效），但會改變對象的狀態。
查詢（查詢）：返回結果，但是不會改變對象的狀態，對系統沒有副作用。
![iamge](https://images0.cnblogs.com/blog/94031/201408/261851418137013.png)
=>
![image](https://images0.cnblogs.com/blog/94031/201408/261851423609113.png)

主數據庫處理CUD，從庫處理R，從庫的的結構可以和主庫的結構完全一樣，也可以不一樣，從庫主要用來進行只讀的查詢操作。
在數量上從庫的個數也可以根據查詢的規模進行擴展，在業務邏輯上，也可以根據專題從主庫中劃分出不同的從庫。
從庫也可以實現成ReportingDatabase，根據查詢的業務需求，從主庫中抽取一些必要的數據生成一系列查詢報表來存儲。

![image](https://images0.cnblogs.com/blog/94031/201408/261851432666257.png)
使用ReportingDatabase的一些優點通常可以使得查詢變得更加簡單高效：
ReportingDatabase的結構和數據表會針對常用的查詢請求進行設計。
ReportingDatabase數據庫通常會去正規化，存儲一些冗餘而減少必要的加入等聯合查詢操作，使得查詢簡化和高效，一些在主數據庫中用不到的數據信息，在ReportingDatabase可以不用存儲。
可以對ReportingDatabase重構優化，而不用去改變操作數據庫。
對ReportingDatabase數據庫的查詢不會給操作數據庫帶來任何壓力。
可以針對不同的查詢請求建立不同的ReportingDatabase庫。
當然這也有一些缺點，比如從庫數據的更新。如果使用SQLServer的，本身也提供了一些如故障轉移和複製機制來方便部署。


什麼時候可以考慮CQRS:

CQRS模式有一些優點：

分工明確，可以負責不同的部分
將業務上的命令和查詢的職責分離能夠提高系統的性能，可擴展性和安全性。\並且在系統的演化中能夠保持高度的靈活性，能夠防止出現CRUD模式中，對查詢或者修改中的某一方進行改動，導致另一方出現問題的情況。
邏輯清晰，能夠看到系統中的那些行為或者操作導致了系統的狀態變化。
可以從數據驅動（Data-Driven）轉到任務驅動（Task-Driven）以及事件驅動（Event-Driven）。

在下場景中，可以考慮使用CQRS模式：

當在業務邏輯層有很多操作需要相同的實體或者對象進行操作的時候.CQRS使得我們可以對讀和寫定義不同的實體和方法，從而可以減少或者避免對某一方面的更改造成衝突
對於一些基於任務的用戶交互系統，通常這類系統會引導用戶通過一系列複雜的步驟和操作，通常會需要一些複雜的領域模型，並且整個團隊已經熟悉領域驅動設計技術。寫模型有很多和業務邏輯相關的命令操作的堆，輸入驗證，業務邏輯驗證來保證數據的一致性。讀模型沒有業務邏輯以及驗證堆，僅僅是返回DTO對象為視圖模型提供數據。讀模型最終和寫模型相一致。
適用於一些需要對查詢性能和寫入性能分開進行優化的系統，尤其是讀/寫比非常高的系統，橫向擴展是必須的。比如，在很多系統中讀操作的請求時遠大於寫操作。為適應這種場景，可以考慮將寫模型抽離出來單獨擴展，而將寫模型運行在一個或者少數幾個實例上。少量的寫模型實例能夠減少合併衝突發生的情況
適用於一些團隊中，一些有經驗的開發者可以關注複雜的領域模型，這些用到寫操作，而另一些經驗較少的開發者可以關注用戶界面上的讀模型。
對於系統在將來會隨著時間不段演化，有可能會包含不同版本的模型，或者業務規則經常變化的系統
需要和其他系統整合，特別是需要和事件溯源事件採購進行整合的系統，這樣子系統的臨時異常不會影響整個系統的其他部分。
但是在以下場景中，可能不適宜使用CQRS：

領域模型或者業務邏輯比較簡單，這種情況下使用CQRS會把系統搞複雜。
對於簡單的，CRUD模式的用戶界面以及與之相關的數據訪問操作已經足夠的話，沒必要使用CQRS，這些都是一個簡單的對數據進行增刪改查。
不適合在整個系統中到處使用該模式。在整個數據管理場景中的特定模塊中CQRS可能比較有用。但是在有些地方使用CQRS會增加系統不必要的複雜性。


CQRS與Event Sourcing的關係
在CQRS中，查詢方面，直接通過方法查詢數據庫，然後通過DTO將數據返回。
在操作（命令）方面，是通過發送命令實現，由CommandBus處理特定的命令，然後由司令部將特定的事件發布到EventBus上，然後EventBus使用特定的處理程序來處理事件，執行一些諸如，修改，刪除，更新等操作。這裡，所有與命令相關的操作都通過事件實現。這樣我們可以通過記錄事件來記錄系統的運行歷史記錄 ，並且能夠方便的回滾到某一歷史狀態.Event Sourcing就是用來進行存儲和管理事件的。

![image](https://www.codeproject.com/KB/architecture/555855/CQRS.jpg)
上圖很清晰的說明了CQRS在讀寫方面的分離，在讀方面，通過QueryFacade到數據庫裡去讀取數據，這個庫有可能是ReportingDB。在寫方面，比較複雜，操作通過命令發送到CommandBus上，然後特定的CommandHandler處理請求，產生對應的事件，將Eevnt持久化後，通過EventBus特定的EevntHandler對數據庫進行修改等操作。

![image](https://images0.cnblogs.com/blog/94031/201408/261851449547571.png)

